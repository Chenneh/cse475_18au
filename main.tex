\documentclass{article}
\usepackage[utf8]{inputenc}
\usepackage[margin=0.5in]{geometry}
\usepackage{datetime2}
\usepackage{bytefield}
\usepackage{algorithm,algpseudocode}
\usepackage{amsmath,amsfonts}
\usepackage{makecell}
\setlength{\parindent}{0pt}

\title{CSE 475 Creature Spec}
\author{Ryan Rowe, Austin Beaulieu}
\date{Rev. \today~\DTMcurrenttime}

\newcommand{\ind}[1]{\ensuremath{[\![#1]\!]}}
\newcommand{\code}{\texttt}
\newcommand{\hex}[1]{\texttt{0x#1}}
\newcommand{\bin}[1]{\texttt{0b#1}}
\newcommand{\uint}[1]{\code{uint#1\_t}}
\newcommand{\sint}[1]{\code{int#1\_t}}
\newcommand{\float}{\code{float}}
\newcommand{\assign}{\ensuremath{\leftarrow}}
\newcommand{\rand}{\text{rand}}

\begin{document}

\maketitle

\section{The Creature Algorithm}

\subsection{Initialization}
When each creature turns on, it must go through initialization:

\begin{enumerate}
    \item Wait for communication with Controller
    \item Receive \& set data from AdjustGlobals packet
    \item Initialize current state randomly from the list of standard states
\end{enumerate}

\subsection{Loop}
For every \code{RepeatCycle} amount of time, run the following process:
\begin{enumerate}
    \item If the controller sends PlaySoundN or PlayEffectN, play that sound and/or effect, else play current state
    \item Start the radio and set listen timer for $\rand(\code{minListen}, \code{maxListen})$ milliseconds for other creatures and/or the controller
    \item Calculate the transition to the next state
    \item Set a timer for \code{minListen} for sending the new state to other creatures when timer fired
\end{enumerate}


\subsection{Bookkeeping}
Each creature needs to maintain values pertaining to the global state of the creature network and to the internal state of the creature itself. This section outlines these values.

\subsubsection{Global Values}
Creatures will receive state transition packets from other creatures. Each should maintain a list of the states other creatures are in and update this as it changes. We refer to this as the \code{StateList}. The creature should also maintain a running average of RSSI from these packets. This average should serve as a reasonably accurate heuristic for the distances from other creatures. We refer to this as \code{DistanceList}.
\subsubsection{Local Values}
Time since last spook
SpookThreshold
Current state
Repeat state



\clearpage
\section{Packet Protocol}

Packets are sent and received in the following format. The first byte is the packet identifier, followed by the originating address (either $2^{\mbox{kit}}$ or $2^{\mbox{kit}} - 1$) and destination address. To send a packet to all creatures, use the broadcast address \hex{FF}.\\

\begin{bytefield}[bitwidth=\textwidth/48]{48}
\bitheader{0-24}\\
\bitbox{8}{\uint{8} \code{packetID}}
\bitbox{8}{\uint{8} \code{srcAddr}}
\bitbox{8}{\uint{8} \code{destAddr}}
\bitbox{24}{\uint{8} \code{payload[sizeof(packet) - 3]}}
\end{bytefield}

\subsection{Packet Types}

All payload contents are listed by their byte offset inside the payload array.

\begingroup
\renewcommand{\thesubsubsection}{PID \hex{\ifnum\value{subsubsection}<10 0\fi\arabic{subsubsection}}}
\subsubsection{Set Globals}

Updates a series of creature variables. Only valid \code{if sourceAddr == 0}.\\

\begin{tabular}{r|l|l|l}
\textbf{Byte} & \textbf{Variable} & \textbf{Default} & \textbf{Description}\\\hline
0 & \uint{16} \code{TX\_POWER} & 1 & Radio transmit power\\
2 & \uint{8} \code{SPOOK\_RAND\_MIN} & 100 & Minimum bound when generating spook strength\\
3 & \uint{8} \code{SPOOK\_RAND\_MAX} & 200 & Maximum bound when generating spook strength\\
4 & \uint{8} \code{SPOOK\_MAX} & 255 & Maximum spook strength\\
5 & \uint{8} \code{SPOOK\_THRESHOLD} & 150 & Trigger threshold for being spookd\\
\end{tabular}

\subsubsection{Stop}

Enter \textsc{wait} state. Only valid \code{if sourceAddr == 0}.

\subsubsection{Start}

Enter \textsc{wait} state. Only valid \code{if sourceAddr == 0}.

\begin{tabular}{r|l|l|l}
\textbf{Byte} & \textbf{Variable} & \textbf{Description}\\\hline
0 & \uint{8} \code{mode} & \
\end{tabular}

\subsubsection{Spook}
\subsubsection{Entered State}
\subsubsection{Report Local Topology}
\subsubsection{Broadcast Topology}
\endgroup

\clearpage
\section{Global Values}

\clearpage
\section{Spooks}
A creature can enter into the \textsc{spook} state from one of two ways: a rising edge from the PIR sensor (0 to 1) or from a spook passed on from another creature. 
Each creature has an internal spook threshold that lowered proportional to the time since the last spook.
When a spook occurs, a strength is randomly generated which decides how `large' the spook is.
This value is used to determine if the creature is actually spookd by comparing it to the current spook threshold. If it does, it enters into a spook state, and then passes on this spook.
This value could be used to determine how great a response is--perhaps by volume or length.\\

\textsc{spook} is called when the PIR sensor is activated. \textsc{spook} must also maintain internal state in order to prevent double spooks by the same PIR detection.
\begin{algorithm}
    \begin{algorithmic}[1]
        \Function{spook}{}\\
            \qquad strength $\longleftarrow \min\left\{255, \rand(\code{SPOOK\_MIN},  \code{SPOOK\_MAX}) * \left(1 - \frac{255}{\code{SPOOK\_TREHSOLD}} \cdot 0.5 + 1\right)\right\}$\\
            \qquad rxSpookd(strength, rand(0, 255))
        \EndFunction
    \end{algorithmic}
\end{algorithm}

\textsc{rxSpookd} is called afterwards, and when one is passed on from another creature
\begin{algorithm}
    \begin{algorithmic}[1]
        \State $\code{lastSpookID} \assign $nonlocal value holding the last recieved spook ID
        \Function{rxSpookd}{\code{spookStrength, spookID}}
            \If{$\code{spookID} \neq \code{lastSpookID} \And \code{spookStrength} \geq \texttt{SPOOK\_TRESHOLD}$}
                \State playSpookSound() // Do not broadcast packet notifying sound played
                \State $\code{SPOOK\_THRESHOLD} = \rand(\code{SPOOK\_THRESHOLD}, 255)$
                \State sendSpookPacket$(\code{spookStrength} * \code{SPOOK\_DECAY}, \code{spookID})$
                \State \code{lastSpookID} \assign \code{spookID}
            \Else
                \State $\code{SPOOK\_THRESHOLD} = \max\{0, \code{SPOOK\_THRESHOLD} - \code{SPOOK\_INCREMENT}\}$
            \EndIf
        \EndFunction
    \end{algorithmic}
\end{algorithm}

Each state class will define a spook threshold modifier. This is a positive floating point value that defines the state's threshold relative to the globally defined threshold that was broadcast by the controller:\\
$\code{StateThreshold} = \code{StateThresholdModifier} \cdot \code{GlobalThreshold}$\\

Each state class will also define a spook increment that determines how much the spook threshold changes per time cycle. This does not need to be called every cycle, since we will keep an internal record of the amound of time since the last spook:\\
$\code{StateThreshold} -= \code{StateThresholdModifier} \cdot \code{TimeSinceSpook}$\\

When a creature transitions from one state to another, it should copy over its current StateThreshold. Because of this, we must use the above equation to decrement the \code{StateThreshold} before passing it onto the next state, since in the new state \code{TimeSinceSpook} will be 0. 



\clearpage
\section{States}

\subsection{Normal States}

Ambient 1 - 3\\
Active 1 - 3\\
Loud 1 - 3\\

\subsection{Pause And Listen State}


\subsection{Spook State}




\clearpage
\section{State Transitions}
All creatures will have a predetermined number of states that they can enter into, with reasonably similar intention for the state itself. This does not mean that they will be similar in how they are implemented, but rather that certain states, like a spook state, convey a similar tone as that of other creatures.\\

Let $\mathbb{S}$ be the set of all states a creature can enter into\\
Let $d$ be the number of possible creature states\\
Let $N$ be the number of all creatures\\

Each creature will be able to enter into one of $\mathbb{S}$. To compute this, we will a few things:
\begin{enumerate}
    \item $\mathbb{C}$ : The set representing the record of the current state of all other $N$ creatures. 
    \item $\mathbb{W}_i \in \mathbb{R}^d$: The set of relative weights for transitions into its next state based on this creature's current state (higher weights being more likely). 
    \item $\mathbb{L}_i \in \mathbb{R}^d$: The set of scalars used for determining the weight that other creatures of the same state have on this creature's likelihood of transitioning into that state.  If a scalar $\mathbb{L}_n > 0$, then it directly scales with respect to the number of creatures in state $\mathbb{C}_n$, else if $\mathbb{L}_n < 0$, it is inversely proportional 
    \item $\mathbb{O}_i \in \mathbb{R}^N$ : The distance from this creature to the $N$ other creatures
    \item $\mathbb{D}_i \in \mathbb{R}^N$ : The inverse distances of the $N$ creatures to this creature derived from $\mathbb{O}$. If $\mathbb{O}_i \neq 0$ then $\mathbb{D}_i = 1 / \mathbb{O}_i$, else $\mathbb{D}_i = 0$
\end{enumerate}

The final weight for a transition from state $\mathbb{S}_i$ to state $\mathbb{S}_j$ is calculated as follows:\\

$\widetilde{\mathbb{L}}_{i,j} = \mathbb{L}_{i,j} \cdot \frac{N - \sum^{N}_{k = 0} \ind{\mathbb{C}_k = \mathbb{S}_j}}{N}$\\\\

$\mathbb{P} = {\left\{\mathbb{W}_{i,j} + \widetilde{\mathbb{L}}_{i,j} \cdot \sum^{N}_{k = 0} \mathbb{D}_{i,j} \ind{\mathbb{C}_k = \mathbb{S}_j}\right\}}_{j = 1}^N$ for each creature $\mathbb{C}_i$\\\\

$\widetilde{\mathbb{P}} = {\left\{ \sum_{i=1}^j \mathbb{P}_i \right\}}^N_{j=1}$\\\\

Let $R = \texttt{Random}(0, \widetilde{\mathbb{P}}_N)$

\begin{algorithm}
    \begin{algorithmic}[1]
        \For{$i \in \left\{1,...,N\right\}$}
            \If{$R < \widetilde{\mathbb{P}}_i$}
                \State Let $\mathbb{S}_i$ be the next state to transition to
            \EndIf
        \EndFor
    \end{algorithmic}
\end{algorithm}


\end{document}
